name: Semantic Docker Build with Professional Release Notes

on:
  push:
    branches: [ main, master ]

# Prevent concurrent releases
concurrency:
  group: semantic-release
  cancel-in-progress: false

env:
  IMAGE_NAME: jyothiram266/doc-semver

jobs:
  semantic-version-and-build:
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      packages: write
      pull-requests: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get latest tag
        id: get_tag
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "Latest tag: $LATEST_TAG"

      - name: Check for new commits
        id: check_commits
        run: |
          LATEST_TAG="${{ steps.get_tag.outputs.latest_tag }}"
          
          if [ "$LATEST_TAG" = "v0.0.0" ]; then
            COMMIT_COUNT=$(git rev-list --count HEAD)
          else
            COMMIT_COUNT=$(git rev-list --count ${LATEST_TAG}..HEAD 2>/dev/null || echo "0")
          fi
          
          echo "commit_count=$COMMIT_COUNT" >> $GITHUB_OUTPUT
          
          if [ "$COMMIT_COUNT" -eq 0 ]; then
            echo "No new commits since last tag ($LATEST_TAG)"
            echo "has_commits=false" >> $GITHUB_OUTPUT
          else
            echo "Found $COMMIT_COUNT new commit(s) since last tag"
            echo "has_commits=true" >> $GITHUB_OUTPUT
          fi

      - name: Analyze commits for version bump
        id: version_bump
        if: steps.check_commits.outputs.has_commits == 'true'
        run: |
          LATEST_TAG="${{ steps.get_tag.outputs.latest_tag }}"
          
          if [ "$LATEST_TAG" = "v0.0.0" ]; then
            COMMITS=$(git log --pretty=format:"%s" HEAD)
          else
            COMMITS=$(git log --pretty=format:"%s" ${LATEST_TAG}..HEAD)
          fi
          
          echo "Commits to analyze:"
          echo "$COMMITS"
          
          HAS_MAJOR=false
          HAS_MINOR=false
          HAS_PATCH=false
          
          # Check for major keyword (highest priority)
          if echo "$COMMITS" | grep -qiE "^major:"; then
            HAS_MAJOR=true
          fi
          
          # Check for minor keyword
          if echo "$COMMITS" | grep -qiE "^minor:"; then
            HAS_MINOR=true
          fi
          
          # Check for patch keyword
          if echo "$COMMITS" | grep -qiE "^patch:"; then
            HAS_PATCH=true
          fi
          
          # Determine bump type (priority: major > minor > patch)
          # Every push MUST increment something, defaulting to patch
          if [ "$HAS_MAJOR" = true ]; then
            BUMP_TYPE="major"
            echo "MAJOR keyword detected - MAJOR version bump"
          elif [ "$HAS_MINOR" = true ]; then
            BUMP_TYPE="minor"
            echo "MINOR keyword detected - MINOR version bump"
          elif [ "$HAS_PATCH" = true ]; then
            BUMP_TYPE="patch"
            echo "PATCH keyword detected - PATCH version bump"
          else
            BUMP_TYPE="patch"
            echo "No keyword detected - defaulting to PATCH version bump"
          fi
          
          echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT

      - name: Calculate new version
        id: new_version
        if: steps.check_commits.outputs.has_commits == 'true'
        run: |
          LATEST_TAG="${{ steps.get_tag.outputs.latest_tag }}"
          BUMP_TYPE="${{ steps.version_bump.outputs.bump_type }}"
          
          VERSION=${LATEST_TAG#v}
          VERSION=$(echo "$VERSION" | sed 's/-.*$//')
          
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"
          
          MAJOR=${MAJOR:-0}
          MINOR=${MINOR:-0}
          PATCH=${PATCH:-0}
          
          MAJOR=$(echo "$MAJOR" | grep -o '[0-9]*' | head -1)
          MINOR=$(echo "$MINOR" | grep -o '[0-9]*' | head -1)
          PATCH=$(echo "$PATCH" | grep -o '[0-9]*' | head -1)
          
          MAJOR=${MAJOR:-0}
          MINOR=${MINOR:-0}
          PATCH=${PATCH:-0}
          
          case $BUMP_TYPE in
            "major")
              NEW_MAJOR=$((MAJOR + 1))
              NEW_MINOR=0
              NEW_PATCH=0
              ;;
            "minor")
              NEW_MAJOR=$MAJOR
              NEW_MINOR=$((MINOR + 1))
              NEW_PATCH=0
              ;;
            "patch")
              NEW_MAJOR=$MAJOR
              NEW_MINOR=$MINOR
              NEW_PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
          
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Previous version: $LATEST_TAG"
          echo "New version: $NEW_VERSION"

      - name: Check if version already exists
        id: check_version
        if: steps.check_commits.outputs.has_commits == 'true'
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
          
          if git rev-parse "v$NEW_VERSION" >/dev/null 2>&1; then
            echo "ERROR: Tag v$NEW_VERSION already exists!"
            exit 1
          else
            echo "Version v$NEW_VERSION is available"
          fi

      - name: Set up Docker Buildx
        if: steps.check_commits.outputs.has_commits == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        if: steps.check_commits.outputs.has_commits == 'true'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push Docker image
        if: steps.check_commits.outputs.has_commits == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:${{ steps.new_version.outputs.new_version }}
            ${{ env.IMAGE_NAME }}:latest
          labels: |
            org.opencontainers.image.version=${{ steps.new_version.outputs.new_version }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Extract commit and PR information
        id: extract_changes
        if: steps.check_commits.outputs.has_commits == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          LATEST_TAG="${{ steps.get_tag.outputs.latest_tag }}"
          
          # Get all commits with their hashes
          if [ "$LATEST_TAG" = "v0.0.0" ]; then
            COMMITS=$(git log --pretty=format:"%H%x09%s%x09%b%x09%an" HEAD)
          else
            COMMITS=$(git log --pretty=format:"%H%x09%s%x09%b%x09%an" ${LATEST_TAG}..HEAD)
          fi
          
          # Initialize arrays for different categories
          MAJOR_CHANGES=""
          MINOR_CHANGES=""
          PATCH_CHANGES=""
          OTHER_CHANGES=""
          
          # Counters
          MAJOR_COUNT=0
          MINOR_COUNT=0
          PATCH_COUNT=0
          OTHER_COUNT=0
          
          # Process each commit
          while IFS=$'\t' read -r hash subject body author; do
            if [ -z "$hash" ]; then continue; fi
            
            # Short hash for display
            SHORT_HASH=$(echo "$hash" | cut -c1-7)
            COMMIT_LINK="https://github.com/${{ github.repository }}/commit/$hash"
            
            # Try to find associated PR number
            PR_NUM=$(gh pr list --state merged --search "$hash" --json number --jq '.[0].number' 2>/dev/null || echo "")
            
            if [ -n "$PR_NUM" ]; then
              PR_LINK="[#${PR_NUM}](https://github.com/${{ github.repository }}/pull/${PR_NUM})"
              REFERENCE="$PR_LINK ([$SHORT_HASH]($COMMIT_LINK))"
            else
              REFERENCE="[$SHORT_HASH]($COMMIT_LINK)"
            fi
            
            # Clean subject (remove keyword prefix for display)
            CLEAN_SUBJECT=$(echo "$subject" | sed -E 's/^(major|minor|patch): *//')
            
            # Categorize by keyword
            if echo "$subject" | grep -qiE "^major:"; then
              MAJOR_COUNT=$((MAJOR_COUNT + 1))
              MAJOR_CHANGES="${MAJOR_CHANGES}- ${CLEAN_SUBJECT} ${REFERENCE}
          "
            elif echo "$subject" | grep -qiE "^minor:"; then
              MINOR_COUNT=$((MINOR_COUNT + 1))
              MINOR_CHANGES="${MINOR_CHANGES}- ${CLEAN_SUBJECT} ${REFERENCE}
          "
            elif echo "$subject" | grep -qiE "^patch:"; then
              PATCH_COUNT=$((PATCH_COUNT + 1))
              PATCH_CHANGES="${PATCH_CHANGES}- ${CLEAN_SUBJECT} ${REFERENCE}
          "
            else
              OTHER_COUNT=$((OTHER_COUNT + 1))
              OTHER_CHANGES="${OTHER_CHANGES}- ${CLEAN_SUBJECT} ${REFERENCE}
          "
            fi
          done <<< "$COMMITS"
          
          # Save to outputs using EOF delimiters
          {
            echo "major_changes<<EOF"
            echo "$MAJOR_CHANGES"
            echo "EOF"
          } >> $GITHUB_OUTPUT
          
          {
            echo "minor_changes<<EOF"
            echo "$MINOR_CHANGES"
            echo "EOF"
          } >> $GITHUB_OUTPUT
          
          {
            echo "patch_changes<<EOF"
            echo "$PATCH_CHANGES"
            echo "EOF"
          } >> $GITHUB_OUTPUT
          
          {
            echo "other_changes<<EOF"
            echo "$OTHER_CHANGES"
            echo "EOF"
          } >> $GITHUB_OUTPUT
          
          echo "major_count=$MAJOR_COUNT" >> $GITHUB_OUTPUT
          echo "minor_count=$MINOR_COUNT" >> $GITHUB_OUTPUT
          echo "patch_count=$PATCH_COUNT" >> $GITHUB_OUTPUT
          echo "other_count=$OTHER_COUNT" >> $GITHUB_OUTPUT

      - name: Get statistics
        id: stats
        if: steps.check_commits.outputs.has_commits == 'true'
        run: |
          LATEST_TAG="${{ steps.get_tag.outputs.latest_tag }}"
          
          # Get unique contributors
          if [ "$LATEST_TAG" = "v0.0.0" ]; then
            CONTRIBUTORS=$(git log --pretty=format:"%an" HEAD | sort -u | wc -l)
            CONTRIBUTORS_LIST=$(git log --pretty=format:"%an" HEAD | sort -u | paste -sd ", " -)
          else
            CONTRIBUTORS=$(git log --pretty=format:"%an" ${LATEST_TAG}..HEAD | sort -u | wc -l)
            CONTRIBUTORS_LIST=$(git log --pretty=format:"%an" ${LATEST_TAG}..HEAD | sort -u | paste -sd ", " -)
          fi
          
          # Get files changed
          if [ "$LATEST_TAG" = "v0.0.0" ]; then
            FILES_CHANGED=$(git diff --name-only $(git hash-object -t tree /dev/null) HEAD 2>/dev/null | wc -l || echo "0")
            LINES_ADDED=$(git diff --shortstat $(git hash-object -t tree /dev/null) HEAD 2>/dev/null | grep -oP '\d+(?= insertion)' || echo "0")
            LINES_DELETED=$(git diff --shortstat $(git hash-object -t tree /dev/null) HEAD 2>/dev/null | grep -oP '\d+(?= deletion)' || echo "0")
          else
            FILES_CHANGED=$(git diff --name-only ${LATEST_TAG}..HEAD 2>/dev/null | wc -l || echo "0")
            LINES_ADDED=$(git diff --shortstat ${LATEST_TAG}..HEAD 2>/dev/null | grep -oP '\d+(?= insertion)' || echo "0")
            LINES_DELETED=$(git diff --shortstat ${LATEST_TAG}..HEAD 2>/dev/null | grep -oP '\d+(?= deletion)' || echo "0")
          fi
          
          echo "contributors=$CONTRIBUTORS" >> $GITHUB_OUTPUT
          echo "contributors_list=$CONTRIBUTORS_LIST" >> $GITHUB_OUTPUT
          echo "files_changed=$FILES_CHANGED" >> $GITHUB_OUTPUT
          echo "lines_added=$LINES_ADDED" >> $GITHUB_OUTPUT
          echo "lines_deleted=$LINES_DELETED" >> $GITHUB_OUTPUT

      - name: Generate professional release notes
        id: release_notes
        if: steps.check_commits.outputs.has_commits == 'true'
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
          LATEST_TAG="${{ steps.get_tag.outputs.latest_tag }}"
          BUMP_TYPE="${{ steps.version_bump.outputs.bump_type }}"
          TOTAL_COMMITS=${{ steps.check_commits.outputs.commit_count }}
          
          # Get extracted data
          MAJOR_COUNT=${{ steps.extract_changes.outputs.major_count }}
          MINOR_COUNT=${{ steps.extract_changes.outputs.minor_count }}
          PATCH_COUNT=${{ steps.extract_changes.outputs.patch_count }}
          OTHER_COUNT=${{ steps.extract_changes.outputs.other_count }}
          
          CONTRIBUTORS=${{ steps.stats.outputs.contributors }}
          CONTRIBUTORS_LIST="${{ steps.stats.outputs.contributors_list }}"
          FILES_CHANGED=${{ steps.stats.outputs.files_changed }}
          LINES_ADDED=${{ steps.stats.outputs.lines_added }}
          LINES_DELETED=${{ steps.stats.outputs.lines_deleted }}
          
          RELEASE_DATE=$(date -u '+%B %d, %Y')
          
          # Start building release notes
          cat > release_notes.md << EOF
          # Release ${NEW_VERSION}
          
          **Released:** ${RELEASE_DATE}
          
          This release includes ${TOTAL_COMMITS} commit(s) across ${FILES_CHANGED} file(s) with ${LINES_ADDED} insertions and ${LINES_DELETED} deletions.
          
          EOF
          
          # Add major changes section if any
          if [ "$MAJOR_COUNT" -gt 0 ]; then
            cat >> release_notes.md << 'EOF'
          ## Breaking Changes
          
          This release contains breaking changes. Please review the changes below carefully before upgrading.
          
          EOF
            
            if [ -n "${{ steps.extract_changes.outputs.major_changes }}" ]; then
              cat >> release_notes.md << 'EOF'
          ${{ steps.extract_changes.outputs.major_changes }}
          
          EOF
            fi
            
            cat >> release_notes.md << EOF
          
          **Migration Guide:** Please refer to the [full changelog](https://github.com/${{ github.repository }}/compare/${LATEST_TAG}...v${NEW_VERSION}) for detailed upgrade instructions.
          
          EOF
          fi
          
          # Add minor changes section
          if [ "$MINOR_COUNT" -gt 0 ]; then
            cat >> release_notes.md << EOF
          ## New Features
          
          EOF
            
            if [ -n "${{ steps.extract_changes.outputs.minor_changes }}" ]; then
              cat >> release_notes.md << 'EOF'
          ${{ steps.extract_changes.outputs.minor_changes }}
          
          EOF
            fi
          fi
          
          # Add patch changes section
          if [ "$PATCH_COUNT" -gt 0 ]; then
            cat >> release_notes.md << EOF
          ## Bug Fixes and Improvements
          
          EOF
            
            if [ -n "${{ steps.extract_changes.outputs.patch_changes }}" ]; then
              cat >> release_notes.md << 'EOF'
          ${{ steps.extract_changes.outputs.patch_changes }}
          
          EOF
            fi
          fi
          
          # Add other changes section
          if [ "$OTHER_COUNT" -gt 0 ]; then
            cat >> release_notes.md << EOF
          ## Other Changes
          
          EOF
            
            if [ -n "${{ steps.extract_changes.outputs.other_changes }}" ]; then
              cat >> release_notes.md << 'EOF'
          ${{ steps.extract_changes.outputs.other_changes }}
          
          EOF
            fi
          fi
          
          # Docker installation section
          cat >> release_notes.md << EOF
          ## Installation
          
          ### Docker
          
          Pull the image using one of the following commands:
          
          \`\`\`bash
          docker pull ${{ env.IMAGE_NAME }}:${NEW_VERSION}
          \`\`\`
          
          Or use the latest tag:
          
          \`\`\`bash
          docker pull ${{ env.IMAGE_NAME }}:latest
          \`\`\`
          
          ### Upgrade Instructions
          
          To upgrade from a previous version:
          
          \`\`\`bash
          # Stop the existing container
          docker stop <container-name>
          
          # Pull the new version
          docker pull ${{ env.IMAGE_NAME }}:${NEW_VERSION}
          
          # Start with the new version
          docker run -d --name <container-name> ${{ env.IMAGE_NAME }}:${NEW_VERSION}
          \`\`\`
          
          EOF
          
          # Contributors section
          if [ "$CONTRIBUTORS" -gt 0 ]; then
            cat >> release_notes.md << EOF
          ## Contributors
          
          This release was made possible by ${CONTRIBUTORS} contributor(s):
          
          ${CONTRIBUTORS_LIST}
          
          EOF
          fi
          
          # Links section
          cat >> release_notes.md << EOF
          ## Additional Resources
          
          - **Docker Hub:** https://hub.docker.com/r/${{ env.IMAGE_NAME }}
          - **Full Changelog:** https://github.com/${{ github.repository }}/compare/${LATEST_TAG}...v${NEW_VERSION}
          - **Source Code:** https://github.com/${{ github.repository }}/tree/v${NEW_VERSION}
          - **Report Issues:** https://github.com/${{ github.repository }}/issues/new
          - **Documentation:** https://github.com/${{ github.repository }}#readme
          
          ---
          
          For questions or support, please open an issue on GitHub.
          EOF
          
          echo "release_notes_file=release_notes.md" >> $GITHUB_OUTPUT
          
          # Preview
          echo "=== GENERATED RELEASE NOTES ==="
          cat release_notes.md
          echo "==============================="

      - name: Create GitHub Release
        if: steps.check_commits.outputs.has_commits == 'true'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.new_version.outputs.new_version }}
          name: "Release ${{ steps.new_version.outputs.new_version }}"
          body_path: release_notes.md
          draft: false
          prerelease: false
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload release notes as artifact
        if: steps.check_commits.outputs.has_commits == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: release-notes-v${{ steps.new_version.outputs.new_version }}
          path: release_notes.md
          retention-days: 90

      - name: Summary
        if: steps.check_commits.outputs.has_commits == 'true'
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # Release v${{ steps.new_version.outputs.new_version }} Published
          
          ## Summary
          - **Type**: ${{ steps.version_bump.outputs.bump_type }}
          - **Total Changes**: ${{ steps.check_commits.outputs.commit_count }} commits
          - **Major Changes**: ${{ steps.extract_changes.outputs.major_count }}
          - **Minor Changes**: ${{ steps.extract_changes.outputs.minor_count }}
          - **Patch Changes**: ${{ steps.extract_changes.outputs.patch_count }}
          - **Other Changes**: ${{ steps.extract_changes.outputs.other_count }}
          
          ## Docker Images
          - \`${{ env.IMAGE_NAME }}:${{ steps.new_version.outputs.new_version }}\`
          - \`${{ env.IMAGE_NAME }}:latest\`
          
          ## Links
          - [View Release](https://github.com/${{ github.repository }}/releases/tag/v${{ steps.new_version.outputs.new_version }})
          - [Full Changelog](https://github.com/${{ github.repository }}/compare/${{ steps.get_tag.outputs.latest_tag }}...v${{ steps.new_version.outputs.new_version }})
          EOF
